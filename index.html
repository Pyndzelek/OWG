<!DOCTYPE html>
<html lang="pl">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>OWGame - Retro Edition</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap"
      rel="stylesheet"
    />
    <style>
      /* --- CSS: UI & Layout (RETRO STYLE) --- */
      :root {
        --retro-green: #4af626;
        --retro-pink: #ff0099;
        --retro-blue: #003cff;
        --retro-bg: rgba(0, 0, 0, 0.85);
      }

      body {
        margin: 0;
        overflow: hidden;
        background-color: #111;
        font-family: "Press Start 2P", cursive; /* Pixel Font */
        touch-action: none;
        user-select: none;
        -webkit-user-select: none;
      }

      #game-container {
        position: relative;
        width: 100vw;
        height: 100vh;
      }

      /* CRT Scanline Effect */
      .scanlines {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: linear-gradient(
          to bottom,
          rgba(255, 255, 255, 0),
          rgba(255, 255, 255, 0) 50%,
          rgba(0, 0, 0, 0.2) 50%,
          rgba(0, 0, 0, 0.2)
        );
        background-size: 100% 4px;
        pointer-events: none;
        z-index: 100;
        opacity: 0.6;
      }

      canvas {
        display: block;
        width: 100%;
        height: 100%;
        image-rendering: pixelated; /* Crisp edges */
      }

      #ui-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        align-items: center;
        z-index: 50;
      }

      /* Animated Score */
      #score-display {
        margin-top: 40px;
        font-size: 32px;
        color: var(--retro-green);
        text-shadow: 4px 4px 0px #000;
        letter-spacing: 2px;
        z-index: 10;
      }

      .panel {
        pointer-events: auto;
        background: var(--retro-bg);
        padding: 2rem;
        text-align: center;
        color: white;
        /* Retro Box Shadow/Border */
        border: 4px solid #fff;
        box-shadow: 8px 8px 0px rgba(0, 0, 0, 0.8);

        position: absolute;
        top: 40%;
        transform: translateY(-50%);
        max-width: 90%;
        min-width: 300px;
        z-index: 20;

        /* Animation */
        animation: slideUp 0.5s ease-out;
      }

      @keyframes slideUp {
        from {
          transform: translateY(-40%) scale(0.9);
          opacity: 0;
        }
        to {
          transform: translateY(-50%) scale(1);
          opacity: 1;
        }
      }

      .hidden {
        display: none !important;
      }

      h1 {
        margin: 0 0 20px 0;
        text-transform: uppercase;
        font-size: 20px;
        line-height: 1.5;
        color: var(--retro-blue);
        text-shadow: 3px 3px 0 #000;
      }

      p {
        color: #ccc;
        font-size: 12px;
        margin-bottom: 25px;
        line-height: 1.6;
      }

      /* Retro Buttons */
      button {
        background: var(--retro-pink);
        color: #fff;
        border: 4px solid #fff;
        padding: 15px 30px;
        font-family: "Press Start 2P", cursive;
        font-size: 14px;
        cursor: pointer;
        text-transform: uppercase;
        box-shadow: 4px 4px 0px #000;
        transition: all 0.1s;
        margin-top: 10px;
      }

      button:active {
        transform: translate(4px, 4px);
        box-shadow: 0px 0px 0px #000;
      }

      button:hover {
        background: #ff4db8;
      }

      /* Level Select Buttons */
      .level-select {
        margin-bottom: 25px;
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 10px;
      }

      .level-btn {
        background: #333;
        border: 2px solid #666;
        padding: 10px;
        font-size: 10px;
        box-shadow: 2px 2px 0 #000;
        opacity: 1;
      }

      .level-btn.active {
        background: var(--retro-green);
        color: #000;
        border-color: #fff;
        animation: blinkBorder 1s infinite;
      }

      @keyframes blinkBorder {
        0% {
          border-color: #fff;
        }
        50% {
          border-color: transparent;
        }
        100% {
          border-color: #fff;
        }
      }

      /* Mobile Controls - Arcade Style */
      #mobile-controls {
        position: absolute;
        bottom: 40px;
        left: 0;
        width: 100%;
        display: flex;
        justify-content: space-between;
        padding: 0 30px;
        box-sizing: border-box;
        pointer-events: none;
        z-index: 15;
      }

      .control-btn {
        pointer-events: auto;
        width: 80px;
        height: 80px;
        background: rgba(255, 255, 255, 0.1);
        border: 4px solid var(--retro-blue);
        border-radius: 10px; /* Squircle for retro feel */
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 30px;
        color: var(--retro-blue);
        box-shadow: 0 0 10px var(--retro-blue);
      }

      .control-btn:active {
        background: var(--retro-blue);
        color: #000;
      }

      @media (min-width: 1025px) {
        #mobile-controls {
          display: none;
        }
      }

      /* Game Over Color */
      #game-over-screen h1 {
        color: #ff3333;
      }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  </head>
  <body>
    <div id="game-container">
      <div class="scanlines"></div>
      <div id="ui-layer">
        <div id="score-display" class="hidden">SCORE: 0</div>

        <div id="start-screen" class="panel">
          <h1 id="game-title">Wybierz Gracza</h1>
          <div class="level-select">
            <button class="level-btn active" onclick="selectLevel(0)">
              Ojoj
            </button>
            <button class="level-btn" onclick="selectLevel(1)">Patec</button>
            <button class="level-btn" onclick="selectLevel(2)">Łatwo</button>
          </div>
          <p>Unikaj przeszkód.<br />Zbieraj monety.</p>
          <button id="start-btn">START GAME</button>
        </div>

        <div id="game-over-screen" class="panel hidden">
          <h1 id="end-title">GAME OVER</h1>
          <p>
            WYNIK:
            <span id="final-score" style="color: var(--retro-green)">0</span>
          </p>
          <button id="restart-btn">TRY AGAIN</button>
        </div>

        <div id="mobile-controls">
          <div id="btn-left" class="control-btn">❮</div>
          <div id="btn-right" class="control-btn">❯</div>
        </div>
      </div>
    </div>

    <script>
      const GAME_PARAMS = {
        physics: {
          laneWidth: 15,
          lanesCount: 5,
          baseSpeed: 0.5,
          maxSpeed: 2.0,
          acceleration: 0.0002,
          playerLerp: 0.2,
        },
        road: {
          length: 400,
          textureRepeats: 20,
        },
        graphics: {
          terrainSpeedFactor: -0.6,
        },
        gameplay: { duration: 30000 },
        spawning: { obstacleRate: 0.05, coinRate: 0.06, buildingRate: 0.08 },
      };

      const LEVELS = [
        {
          name: "Wojtek Piździecki",
          colors: {
            background: 0x87ceeb,
            fog: 0x87ceeb,
            road: "#F4A460",
            terrain: "#E3C896",
            roadStripes: "#F0E68C",
            uiPrimary: "#00ffff", // Retro Blue
            uiDanger: "#FF0000",
            uiSuccess: "#4af626",
          },
          assets: {
            player: { texture: "ojwojtek.png", width: 2.5, height: 4 },
            obstacle: {
              type: "png_sprite",
              texture: "szczecin.png",
              width: 2,
              height: 1,
            },
            coin: { model: "leaf.glb" },
            building: { type: "palm" },
          },
        },
        {
          name: "Patec małpiarz",
          colors: {
            background: 0x2e8b57,
            fog: 0x154025,
            road: "#5C4033",
            terrain: "#2E4F2F",
            roadStripes: "#8B4513",
            uiPrimary: "#4af626",
            uiDanger: "#DC143C",
            uiSuccess: "#ADFF2F",
          },
          assets: {
            player: { texture: "patec.png", width: 2.5, height: 4 },
            obstacle: {
              type: "png_sprite",
              texture: "mini_majk.png",
              width: 2,
              height: 3,
            },
            coin: { model: "banana.glb" },
            building: { type: "tree" },
          },
        },
        {
          name: "Łatwo pijany",
          colors: {
            background: 0x87cefa,
            fog: 0xb0c4de,
            road: "#808080",
            terrain: "#444444",
            roadStripes: "#D3D3D3",
            uiPrimary: "#ff0099",
            uiDanger: "#B22222",
            uiSuccess: "#4169E1",
          },
          assets: {
            player: { texture: "latwo.png", width: 2.5, height: 4 },
            obstacle: {
              type: "png_sprite",
              texture: "shower.png",
              width: 2,
              height: 3,
            },
            coin: { model: "pwio.glb" },
            building: { type: "city_house" },
          },
        },
      ];

      const AssetFactory = {
        textureLoader: new THREE.TextureLoader(),
        gltfLoader: new THREE.GLTFLoader(),

        prototypes: {
          obstacle: null,
          coin: null,
          building: null,
        },
        textures: {},

        loadedModels: {},
        loadingStatus: {},
        waitingCallbacks: {},

        initLevelAssets: function (levelConfig) {
          this.prototypes = { obstacle: null, coin: null, building: null };

          if (levelConfig.assets.building.type === "palm") {
            this.prototypes.building = this.createAttractivePalmPrototype();
          } else if (levelConfig.assets.building.type === "tree") {
            this.prototypes.building = this.createJungleTreePrototype();
          } else {
            this.prototypes.building = this.createCityHousePrototype();
          }

          if (levelConfig.assets.obstacle.type === "png_sprite") {
            this.prototypes.obstacle =
              this.createSpriteObstaclePrototype(levelConfig);
          } else {
            this.prototypes.obstacle =
              this.createGeoObstaclePrototype(levelConfig);
          }
        },

        // --- OPTIMIZED LOAD GLB ---
        loadGLB: function (path, onSuccess) {
          if (this.loadedModels[path]) {
            if (onSuccess) onSuccess(this.loadedModels[path]);
            return;
          }
          if (this.loadingStatus[path] === "loading") {
            if (onSuccess) {
              if (!this.waitingCallbacks[path])
                this.waitingCallbacks[path] = [];
              this.waitingCallbacks[path].push(onSuccess);
            }
            return;
          }
          this.loadingStatus[path] = "loading";
          if (onSuccess) this.waitingCallbacks[path] = [onSuccess];

          this.gltfLoader.load(
            path,
            (gltf) => {
              const rawModel = gltf.scene;
              const box = new THREE.Box3().setFromObject(rawModel);
              const size = box.getSize(new THREE.Vector3());
              const center = box.getCenter(new THREE.Vector3());
              const wrapper = new THREE.Group();
              wrapper.add(rawModel);
              rawModel.position.sub(center);
              const maxDim = Math.max(size.x, size.y, size.z);
              if (maxDim > 0) {
                const targetSize = 1.5;
                const scaleFactor = targetSize / maxDim;
                wrapper.scale.set(scaleFactor, scaleFactor, scaleFactor);
              }
              wrapper.traverse((child) => {
                if (child.isMesh) {
                  child.castShadow = true;
                  child.receiveShadow = true;
                  if (child.material) {
                    child.material.side = THREE.DoubleSide;
                    if (child.material.transparent)
                      child.material.alphaTest = 0.5;
                  }
                }
              });
              this.loadedModels[path] = wrapper;
              this.loadingStatus[path] = "loaded";
              if (this.waitingCallbacks[path]) {
                this.waitingCallbacks[path].forEach((cb) => cb(wrapper));
                delete this.waitingCallbacks[path];
              }
            },
            undefined,
            (err) => {
              console.warn(`GLB Error (${path}):`, err);
              this.loadingStatus[path] = "error";
            }
          );
        },

        createDummyTexture: function (label, colorStr, type) {
          const key = label + colorStr + type;
          if (this.textures[key]) return this.textures[key];

          const cvs = document.createElement("canvas");
          cvs.width = 128;
          cvs.height = 128;
          const ctx = cvs.getContext("2d");

          if (type === "sprite") {
            ctx.clearRect(0, 0, 128, 128);
          } else {
            ctx.fillStyle = colorStr || "#999";
            ctx.fillRect(0, 0, 128, 128);
          }

          if (label.includes("placeholder")) {
            ctx.fillStyle = "white";
            ctx.font = "20px Arial";
            ctx.fillText("?", 50, 60);
          }

          const tex = new THREE.CanvasTexture(cvs);
          tex.magFilter = THREE.NearestFilter; // Retro pixel look
          this.textures[key] = tex;
          return tex;
        },

        createSpriteObstaclePrototype: function (levelConfig) {
          const data = levelConfig.assets.obstacle;
          const geo = new THREE.PlaneGeometry(data.width, data.height);
          let tex;
          if (data.texture.includes("_placeholder")) {
            tex = this.createDummyTexture(data.texture, null, "sprite");
          } else {
            tex = this.textureLoader.load(data.texture);
            tex.magFilter = THREE.NearestFilter;
          }
          const mat = new THREE.MeshStandardMaterial({
            map: tex,
            transparent: true,
            alphaTest: 0.5,
            side: THREE.DoubleSide,
          });
          const mesh = new THREE.Mesh(geo, mat);
          mesh.castShadow = true;
          mesh.userData.isObstacle = true;
          return mesh;
        },

        createGeoObstaclePrototype: function (levelConfig) {
          const oData = levelConfig.assets.obstacle;
          let geo =
            oData.type === "cylinder"
              ? new THREE.CylinderGeometry(0.8, 0.8, 1.5, 12)
              : new THREE.BoxGeometry(1.5, 1.5, 1.5);
          const mat = new THREE.MeshStandardMaterial({
            color: oData.color,
            emissive: oData.emissive || 0x000000,
          });
          const mesh = new THREE.Mesh(geo, mat);
          mesh.castShadow = true;
          return mesh;
        },

        // --- PALM TREE ---
        createAttractivePalmPrototype: function () {
          const group = new THREE.Group();
          const trunkMat = new THREE.MeshStandardMaterial({
            color: 0x8b4513,
            roughness: 1.0,
          });

          // Segmented Trunk
          const positions = [1.5, 4.2, 7.0];
          const radii = [0.8, 0.6, 0.5];

          positions.forEach((y, i) => {
            const geo = new THREE.CylinderGeometry(
              radii[i] * 0.8,
              radii[i],
              3,
              7
            );
            const mesh = new THREE.Mesh(geo, trunkMat);
            mesh.position.y = y;
            if (i > 0) {
              mesh.rotation.x = 0.1 * i;
              mesh.position.z = 0.2 * i;
            }
            group.add(mesh);
          });

          // Leaves Texture
          const leafGeo = new THREE.PlaneGeometry(2, 5);
          leafGeo.translate(0, 2.5, 0); // Pivot at bottom

          const ctx = document.createElement("canvas").getContext("2d");
          ctx.canvas.width = 64;
          ctx.canvas.height = 128;
          ctx.fillStyle = "#fff";
          ctx.beginPath();
          ctx.ellipse(32, 64, 30, 60, 0, 0, Math.PI * 2);
          ctx.fill();
          const leafTex = new THREE.CanvasTexture(ctx.canvas);

          const leafMat = new THREE.MeshStandardMaterial({
            color: 0x228b22,
            map: leafTex,
            alphaMap: leafTex,
            side: THREE.DoubleSide,
            transparent: true,
            alphaTest: 0.5,
          });

          // Layers, Interleaved angles
          const layers = 3;
          const leavesPerLayer = 6;

          for (let L = 0; L < layers; L++) {
            // Offset angle for every other layer to fill gaps
            const angleOffset = (Math.PI / leavesPerLayer) * (L % 2);
            const height = 8.2 - L * 0.5;
            const tilt = Math.PI / 3 - L * 0.1; // Top leaves point up more, bottom down more

            for (let i = 0; i < leavesPerLayer; i++) {
              const leaf = new THREE.Mesh(leafGeo, leafMat);
              const angle = (i / leavesPerLayer) * Math.PI * 2 + angleOffset;

              leaf.position.set(0, height, 0.9);
              leaf.rotation.y = angle;
              leaf.rotation.x = tilt;

              group.add(leaf);
            }
          }

          group.traverse((o) => {
            if (o.isMesh) o.castShadow = true;
          });
          group.scale.set(1.5, 1.5, 1.5);
          return group;
        },

        createJungleTreePrototype: function () {
          const group = new THREE.Group();
          const trunk = new THREE.Mesh(
            new THREE.CylinderGeometry(1, 1.5, 12, 8),
            new THREE.MeshStandardMaterial({ color: 0x5c4033 })
          );
          trunk.position.y = 6;
          trunk.castShadow = true;
          group.add(trunk);
          const leaves = new THREE.Mesh(
            new THREE.DodecahedronGeometry(4),
            new THREE.MeshStandardMaterial({ color: 0x006400 })
          );
          leaves.position.y = 11;
          leaves.castShadow = true;
          group.add(leaves);
          return group;
        },

        createCityHousePrototype: function () {
          const group = new THREE.Group();
          const box = new THREE.Mesh(
            new THREE.BoxGeometry(6, 15, 6),
            new THREE.MeshStandardMaterial({ color: 0x777799 })
          );
          box.position.y = 7.5;
          box.castShadow = true;
          group.add(box);
          return group;
        },

        spawnObstacle: function (levelConfig) {
          if (this.prototypes.obstacle) return this.prototypes.obstacle.clone();
          return new THREE.Mesh(
            new THREE.BoxGeometry(1, 1, 1),
            new THREE.MeshBasicMaterial({ color: 0xff0000 })
          );
        },

        spawnBuilding: function (levelConfig) {
          if (this.prototypes.building) {
            const b = this.prototypes.building.clone();
            if (levelConfig.assets.building.type === "city_house") {
              b.scale.y = 0.8 + Math.random() * 0.5;
            }
            return b;
          }
          return new THREE.Mesh(
            new THREE.BoxGeometry(2, 10, 2),
            new THREE.MeshBasicMaterial({ color: 0x555555 })
          );
        },

        spawnCoin: function (levelConfig) {
          const group = new THREE.Group();
          const cData = levelConfig.assets.coin;

          // Optimization: If loaded, skip fallback creation logic
          if (cData.model && this.loadedModels[cData.model]) {
            group.add(this.loadedModels[cData.model].clone());
            return group;
          }

          // Fallback while loading or if no model
          let geo;
          if (cData.type === "torus")
            geo = new THREE.TorusGeometry(0.3, 0.1, 8, 16);
          else geo = new THREE.OctahedronGeometry(0.5, 0);
          const mat = new THREE.MeshStandardMaterial({
            color: cData.color || 0xffd700,
            emissive: cData.color || 0xffd700,
            emissiveIntensity: 0.6,
          });
          const fallback = new THREE.Mesh(geo, mat);

          if (cData.model) {
            fallback.name = "fallback_mesh";
            group.add(fallback);
            this.loadGLB(cData.model, (loadedModel) => {
              const old = group.getObjectByName("fallback_mesh");
              if (old) group.remove(old);
              group.add(loadedModel.clone());
            });
          } else {
            group.add(fallback);
          }
          return group;
        },

        createPlayer: function (levelConfig) {
          const pGroup = new THREE.Group();
          const pData = levelConfig.assets.player;
          const geometry = new THREE.PlaneGeometry(pData.width, pData.height);
          const fallbackMap = this.createDummyTexture(
            levelConfig.name,
            levelConfig.colors.uiPrimary,
            "default"
          );

          const texture = this.textureLoader.load(
            pData.texture,
            undefined,
            undefined,
            () => {
              mesh.material.map = fallbackMap;
            }
          );
          texture.magFilter = THREE.NearestFilter; // Pixelated Player

          const material = new THREE.MeshStandardMaterial({
            map: texture,
            transparent: true,
            alphaTest: 0.3,
            side: THREE.DoubleSide,
            roughness: 0.4,
          });

          const mesh = new THREE.Mesh(geometry, material);
          mesh.position.y = pData.height / 2;
          mesh.castShadow = true;
          pGroup.add(mesh);
          return pGroup;
        },

        // --- OPTIMIZATION: CACHED TEXTURES ---
        createTerrainTexture: function (levelConfig) {
          const key = "terrain_" + levelConfig.name;
          if (this.textures[key]) return this.textures[key];

          const canvas = document.createElement("canvas");
          canvas.width = 512;
          canvas.height = 512;
          const ctx = canvas.getContext("2d");

          ctx.fillStyle = levelConfig.colors.terrain;
          ctx.fillRect(0, 0, 512, 512);

          ctx.fillStyle = "rgba(0,0,0,0.1)";
          for (let i = 0; i < 400; i++) {
            const x = Math.random() * 512;
            const y = Math.random() * 512;
            const s = 2 + Math.random() * 5;
            ctx.fillRect(x, y, s, s);
          }
          const texture = new THREE.CanvasTexture(canvas);
          texture.wrapS = THREE.RepeatWrapping;
          texture.wrapT = THREE.RepeatWrapping;
          texture.repeat.set(20, 20);
          texture.magFilter = THREE.NearestFilter;

          this.textures[key] = texture;
          return texture;
        },

        createRoadTexture: function (levelConfig) {
          const key = "road_" + levelConfig.name;
          if (this.textures[key]) return this.textures[key];

          const canvas = document.createElement("canvas");
          canvas.width = 512;
          canvas.height = 512;
          const ctx = canvas.getContext("2d");
          const c = levelConfig.colors;
          ctx.fillStyle = c.road;
          ctx.fillRect(0, 0, 512, 512);
          ctx.fillStyle = c.roadStripes;
          ctx.globalAlpha = 0.5;
          const lanePx = 512 / GAME_PARAMS.physics.lanesCount;
          for (let i = 1; i < GAME_PARAMS.physics.lanesCount; i++)
            ctx.fillRect(i * lanePx - 2, 0, 4, 512);
          ctx.globalAlpha = 1.0;
          ctx.fillRect(0, 0, 10, 512);
          ctx.fillRect(502, 0, 10, 512);
          const texture = new THREE.CanvasTexture(canvas);
          texture.wrapS = THREE.RepeatWrapping;
          texture.wrapT = THREE.RepeatWrapping;
          texture.repeat.set(1, GAME_PARAMS.road.textureRepeats);
          texture.magFilter = THREE.NearestFilter;

          this.textures[key] = texture;
          return texture;
        },

        createFinishLine: function () {
          const key = "finish_line";
          if (this.textures[key]) {
          }
          const canvas = document.createElement("canvas");
          canvas.width = 128;
          canvas.height = 32;
          const ctx = canvas.getContext("2d");
          ctx.fillStyle = "#ffffff";
          ctx.fillRect(0, 0, 128, 32);
          ctx.fillStyle = "#000000";
          const size = 16;
          for (let y = 0; y < 2; y++)
            for (let x = 0; x < 8; x++)
              if ((x + y) % 2 === 0)
                ctx.fillRect(x * size, y * size, size, size);
          const tex = new THREE.CanvasTexture(canvas);
          tex.magFilter = THREE.NearestFilter;
          const geo = new THREE.BoxGeometry(
            GAME_PARAMS.physics.laneWidth,
            1,
            4
          );
          const mat = new THREE.MeshStandardMaterial({ map: tex });
          const mesh = new THREE.Mesh(geo, mat);
          mesh.receiveShadow = true;
          return mesh;
        },
      };

      // --- ENGINE VARIABLES ---
      let scene, camera, renderer;
      let currentLevelIndex = 0;
      let activeLevel = LEVELS[0];
      let player, roadMesh, terrainMesh, finishLine;
      let obstacles = [],
        buildings = [],
        coins = [];
      let isRunning = false;
      let score = 0;
      let speed = 0;
      let gameStartTime = 0;
      let finishLineSpawned = false;
      let currentLane = 0;
      let targetX = 0;

      const ui = {
        score: document.getElementById("score-display"),
        start: document.getElementById("start-screen"),
        over: document.getElementById("game-over-screen"),
        finalScore: document.getElementById("final-score"),
        title: document.getElementById("game-title"),
        endTitle: document.getElementById("end-title"),
        btns: document.querySelectorAll(".level-btn"),
      };

      function getLaneX(laneIndex) {
        return (
          laneIndex *
          (GAME_PARAMS.physics.laneWidth / GAME_PARAMS.physics.lanesCount)
        );
      }

      // --- OPTIMIZATION: HELPER TO CLEAN MEMORY ---
      function dispose3DObject(obj) {
        if (!obj) return;
        scene.remove(obj);
        obj.traverse((child) => {
          if (child.isMesh) {
            if (child.geometry) child.geometry.dispose();
            if (child.material) {
              if (Array.isArray(child.material))
                child.material.forEach((m) => m.dispose());
              else child.material.dispose();
            }
          }
        });
      }

      function initEngine() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(
          60,
          window.innerWidth / window.innerHeight,
          0.1,
          200
        );
        camera.position.set(0, 6, 9);
        camera.lookAt(0, 0, -10);

        renderer = new THREE.WebGLRenderer({
          antialias: false,
          powerPreference: "high-performance",
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document
          .getElementById("game-container")
          .appendChild(renderer.domElement);

        const ambLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambLight);

        // Optimized Shadow Camera
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(20, 50, 20);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024; // Lower res for efficiency
        dirLight.shadow.mapSize.height = 1024;
        dirLight.shadow.camera.left = -20;
        dirLight.shadow.camera.right = 20;
        dirLight.shadow.camera.top = 20;
        dirLight.shadow.camera.bottom = -50;
        dirLight.shadow.camera.far = 100;
        scene.add(dirLight);

        setupInputs();
        window.addEventListener("resize", () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        });

        loadLevelVisuals(0);
        animate();
      }

      function loadLevelVisuals(index) {
        currentLevelIndex = index;
        activeLevel = LEVELS[index];
        ui.btns.forEach((btn, i) =>
          btn.classList.toggle("active", i === index)
        );
        ui.title.innerText = activeLevel.name;
        ui.title.style.color = activeLevel.colors.uiPrimary;

        AssetFactory.initLevelAssets(activeLevel);

        // CLEANUP OLD SCENE
        dispose3DObject(player);
        dispose3DObject(roadMesh);
        dispose3DObject(terrainMesh);
        if (finishLine) {
          dispose3DObject(finishLine);
          finishLine = null;
        }
        obstacles.forEach((o) => dispose3DObject(o));
        obstacles = [];
        coins.forEach((c) => dispose3DObject(c));
        coins = [];
        buildings.forEach((b) => dispose3DObject(b));
        buildings = [];

        scene.background = new THREE.Color(activeLevel.colors.background);
        scene.fog = new THREE.Fog(activeLevel.colors.fog, 20, 90);

        // --- ROAD ---
        const rGeo = new THREE.PlaneGeometry(
          GAME_PARAMS.physics.laneWidth,
          GAME_PARAMS.road.length
        );
        const rMat = new THREE.MeshStandardMaterial({
          map: AssetFactory.createRoadTexture(activeLevel),
          roughness: 0.8,
        });
        roadMesh = new THREE.Mesh(rGeo, rMat);
        roadMesh.rotation.x = -Math.PI / 2;
        roadMesh.position.z = -100;
        roadMesh.receiveShadow = true;
        scene.add(roadMesh);

        // --- TERRAIN ---
        const tGeo = new THREE.PlaneGeometry(300, 300);
        const tMat = new THREE.MeshStandardMaterial({
          map: AssetFactory.createTerrainTexture(activeLevel),
          roughness: 1.0,
        });
        terrainMesh = new THREE.Mesh(tGeo, tMat);
        terrainMesh.rotation.x = -Math.PI / 2;
        terrainMesh.position.y = -0.1;
        terrainMesh.position.z = -100;
        terrainMesh.receiveShadow = true;
        scene.add(terrainMesh);

        player = AssetFactory.createPlayer(activeLevel);
        scene.add(player);
      }

      window.selectLevel = function (index) {
        if (isRunning) return;
        loadLevelVisuals(index);
      };

      function startGame() {
        if (isRunning) return;
        score = 0;
        speed = GAME_PARAMS.physics.baseSpeed;
        currentLane = 0;
        targetX = getLaneX(0);
        player.position.x = targetX;
        player.rotation.set(0, 0, 0);

        // Cleanup objects before start
        obstacles.forEach((o) => dispose3DObject(o));
        obstacles = [];
        coins.forEach((c) => dispose3DObject(c));
        coins = [];
        buildings.forEach((b) => dispose3DObject(b));
        buildings = [];
        if (finishLine) {
          dispose3DObject(finishLine);
          finishLine = null;
        }

        ui.start.classList.add("hidden");
        ui.over.classList.add("hidden");
        ui.score.classList.remove("hidden");
        ui.score.innerText = "SCORE: 0";
        gameStartTime = Date.now();
        finishLineSpawned = false;
        isRunning = true;
      }

      function stopGame(reason) {
        isRunning = false;
        ui.score.classList.add("hidden");
        ui.over.classList.remove("hidden");
        if (reason === "finish") {
          score = score * 10;
          ui.endTitle.innerText = "LEVEL CLEAR!";
          ui.endTitle.style.color = activeLevel.colors.uiSuccess;
          ui.finalScore.style.color = activeLevel.colors.uiSuccess;
        } else {
          ui.endTitle.innerText = "GAME OVER";
          ui.endTitle.style.color = "#ff3333";
          ui.finalScore.style.color = "#fff";
        }
        ui.finalScore.innerText = score;
      }

      function returnToMenu() {
        ui.over.classList.add("hidden");
        ui.start.classList.remove("hidden");
        loadLevelVisuals(currentLevelIndex);
      }
      function changeLane(dir) {
        const maxLane = Math.floor(GAME_PARAMS.physics.lanesCount / 2);
        const next = currentLane + dir;
        if (next >= -maxLane && next <= maxLane) {
          currentLane = next;
          targetX = getLaneX(currentLane);
        }
      }

      function update() {
        if (!isRunning) return;
        speed += GAME_PARAMS.physics.acceleration;
        if (speed > GAME_PARAMS.physics.maxSpeed)
          speed = GAME_PARAMS.physics.maxSpeed;

        const timeElapsed = Date.now() - gameStartTime;
        if (!finishLineSpawned && timeElapsed > GAME_PARAMS.gameplay.duration) {
          finishLineSpawned = true;
          finishLine = AssetFactory.createFinishLine();
          finishLine.position.z = -120;
          scene.add(finishLine);
        }

        if (roadMesh.material.map)
          roadMesh.material.map.offset.y -=
            speed / (GAME_PARAMS.road.length / GAME_PARAMS.road.textureRepeats);

        if (terrainMesh && terrainMesh.material.map) {
          const terrainSpeed = speed * GAME_PARAMS.graphics.terrainSpeedFactor;
          terrainMesh.material.map.offset.y -= (terrainSpeed / 300) * 20;
        }

        const maxLane = Math.floor(GAME_PARAMS.physics.lanesCount / 2);
        if (!finishLineSpawned) {
          if (Math.random() < GAME_PARAMS.spawning.obstacleRate) {
            const obs = AssetFactory.spawnObstacle(activeLevel);
            const laneIdx =
              Math.floor(Math.random() * GAME_PARAMS.physics.lanesCount) -
              maxLane;
            obs.position.set(
              getLaneX(laneIdx),
              obs.userData.isObstacle ? 1.5 : 0.75,
              -80
            );
            scene.add(obs);
            obstacles.push(obs);
          }
          if (Math.random() < GAME_PARAMS.spawning.coinRate) {
            const c = AssetFactory.spawnCoin(activeLevel);
            const laneIdx =
              Math.floor(Math.random() * GAME_PARAMS.physics.lanesCount) -
              maxLane;
            c.position.set(getLaneX(laneIdx), 1.0, -80);
            scene.add(c);
            coins.push(c);
          }
        }
        if (Math.random() < GAME_PARAMS.spawning.buildingRate) {
          const b = AssetFactory.spawnBuilding(activeLevel);
          const side = Math.random() > 0.5 ? 1 : -1;
          const dist =
            GAME_PARAMS.physics.laneWidth / 2 + 5 + Math.random() * 5;
          b.position.set(side * dist, 0, -90);
          b.rotation.y = Math.random() * Math.PI * 2;
          scene.add(b);
          buildings.push(b);
        }

        const moveObj = (arr, type) => {
          for (let i = arr.length - 1; i >= 0; i--) {
            const obj = arr[i];
            obj.position.z += speed;
            if (type === "coin") obj.rotation.y += 0.05;

            if (obj.position.z > -1.5 && obj.position.z < 1.5) {
              const dist = Math.abs(obj.position.x - player.position.x);
              if (type === "obstacle" && dist < 1.2) stopGame("crash");
              else if (type === "coin" && dist < 1.2) {
                scene.remove(obj);
                arr.splice(i, 1);
                score += 50;
                ui.score.innerText = "SCORE: " + score;
                continue;
              }
            }
            if (obj.position.z > 20) {
              scene.remove(obj);
              arr.splice(i, 1);
            }
          }
        };
        moveObj(obstacles, "obstacle");
        moveObj(coins, "coin");
        moveObj(buildings, "building");

        if (finishLine) {
          finishLine.position.z += speed;
          if (finishLine.position.z > 0) stopGame("finish");
        }

        player.position.x +=
          (targetX - player.position.x) * GAME_PARAMS.physics.playerLerp;
        const tilt = (player.position.x - targetX) * 0.15;
        player.rotation.z = tilt;
        player.rotation.y = -tilt * 0.5;
      }

      function setupInputs() {
        document.addEventListener("keydown", (e) => {
          if (isRunning) {
            if (e.key === "ArrowLeft") changeLane(-1);
            if (e.key === "ArrowRight") changeLane(1);
          }
        });
        const handleTap = (dir) => (e) => {
          e.preventDefault();
          if (!isRunning) return;
          changeLane(dir);
          // Button feedback
          const btn = e.target.closest(".control-btn");
          if (btn) {
            btn.style.background = "var(--retro-blue)";
            btn.style.color = "#000";
            setTimeout(() => {
              btn.style.background = "rgba(255,255,255,0.1)";
              btn.style.color = "var(--retro-blue)";
            }, 100);
          }
        };
        const btnL = document.getElementById("btn-left");
        const btnR = document.getElementById("btn-right");
        btnL.addEventListener("touchstart", handleTap(-1), { passive: false });
        btnR.addEventListener("touchstart", handleTap(1), { passive: false });
        btnL.addEventListener("mousedown", handleTap(-1));
        btnR.addEventListener("mousedown", handleTap(1));
        document
          .getElementById("start-btn")
          .addEventListener("click", startGame);
        document
          .getElementById("restart-btn")
          .addEventListener("click", returnToMenu);
      }
      function animate() {
        requestAnimationFrame(animate);
        update();
        renderer.render(scene, camera);
      }
      initEngine();
    </script>
  </body>
</html>
