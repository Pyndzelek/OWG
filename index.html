<!DOCTYPE html>
<html lang="pl">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>OWGame - Retro Edition</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap"
      rel="stylesheet"
    />
    <style>
      /* --- CSS: UI & Layout (RETRO STYLE) --- */
      :root {
        --retro-green: #4af626;
        --retro-pink: #ff0099;
        --retro-blue: #ff0099;
        --retro-bg: rgba(0, 0, 0, 0.85);
      }

      body {
        margin: 0;
        overflow: hidden;
        background-color: #111;
        font-family: "Press Start 2P", cursive; /* Pixel Font */
        touch-action: none;
        user-select: none;
        -webkit-user-select: none;
      }

      #game-container {
        position: relative;
        width: 100vw;
        height: 100vh;
      }

      /* CRT Scanline Effect */
      .scanlines {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: linear-gradient(
          to bottom,
          rgba(255, 255, 255, 0),
          rgba(255, 255, 255, 0) 50%,
          rgba(0, 0, 0, 0.2) 50%,
          rgba(0, 0, 0, 0.2)
        );
        background-size: 100% 4px;
        pointer-events: none;
        z-index: 100;
        opacity: 0.6;
      }

      canvas {
        display: block;
        width: 100%;
        height: 100%;
        image-rendering: pixelated; /* Crisp edges */
      }

      #ui-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        align-items: center;
        z-index: 50;
      }

      /* Animated Score */
      #score-display {
        margin-top: 40px;
        font-size: 32px;
        color: var(--retro-green);
        text-shadow: 4px 4px 0px #000;
        letter-spacing: 2px;
        z-index: 10;
      }

      .panel {
        pointer-events: auto;
        background: var(--retro-bg);
        margin: 0px 20px;
        padding: 2rem;
        text-align: center;
        color: white;
        /* Retro Box Shadow/Border */
        border: 4px solid #fff;
        box-shadow: 8px 8px 0px rgba(0, 0, 0, 0.8);

        position: absolute;
        top: 40%;
        transform: translateY(-50%);
        max-width: 90%;
        min-width: 300px;
        z-index: 20;

        /* Animation */
        animation: slideUp 0.5s ease-out;
      }

      @keyframes slideUp {
        from {
          transform: translateY(-40%) scale(0.9);
          opacity: 0;
        }
        to {
          transform: translateY(-50%) scale(1);
          opacity: 1;
        }
      }

      .hidden {
        display: none !important;
      }

      h1 {
        margin: 0 0 20px 0;
        text-transform: uppercase;
        font-size: 20px;
        line-height: 1.5;
        color: var(--retro-blue);
        text-shadow: 3px 3px 0 #000;
      }

      p {
        color: #ccc;
        font-size: 12px;
        margin-bottom: 25px;
        line-height: 1.6;
      }

      /* Retro Buttons */
      button {
        background: var(--retro-pink);
        color: #fff;
        border: 4px solid #fff;
        padding: 15px 30px;
        font-family: "Press Start 2P", cursive;
        font-size: 14px;
        cursor: pointer;
        text-transform: uppercase;
        box-shadow: 4px 4px 0px #000;
        transition: all 0.1s;
        margin-top: 10px;
      }

      button:active {
        transform: translate(4px, 4px);
        box-shadow: 0px 0px 0px #000;
      }

      button:hover {
        background: #ff4db8;
      }

      /* Level Select Buttons */
      .level-select {
        margin-bottom: 25px;
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 10px;
      }

      .level-btn {
        background: #333;
        border: 2px solid #666;
        padding: 10px;
        font-size: 10px;
        box-shadow: 2px 2px 0 #000;
        opacity: 1;
      }

      .level-btn.active {
        background: var(--retro-green);
        color: #000;
        border-color: #fff;
        animation: blinkBorder 1s infinite;
      }

      @keyframes blinkBorder {
        0% {
          border-color: #fff;
        }
        50% {
          border-color: transparent;
        }
        100% {
          border-color: #fff;
        }
      }

      /* Mobile Controls - Arcade Style */
      #mobile-controls {
        position: absolute;
        bottom: 15%;
        left: 0;
        width: 100%;
        display: flex;
        justify-content: space-between;
        padding: 0 30px;
        box-sizing: border-box;
        pointer-events: none;
        z-index: 15;
      }

      .control-btn {
        pointer-events: auto;
        width: 80px;
        height: 80px;
        background: rgba(255, 255, 255, 0.1);
        border: 4px solid var(--retro-blue);
        border-radius: 10px; /* Squircle for retro feel */
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 30px;
        color: var(--retro-blue);
        box-shadow: 0 0 10px var(--retro-blue);
      }

      .control-btn:active {
        background: var(--retro-blue);
        color: #000;
      }

      @media (min-width: 1025px) {
        #mobile-controls {
          display: none;
        }
      }

      /* Game Over Color */
      #game-over-screen h1 {
        color: #ff3333;
      }

      #start-screen,
      #restart-btn,
      #game-over-screen {
        word-spacing: -5px;
        text-align: center;
      }

      #game-title,
      #end-title {
        word-spacing: -10px;
      }
      #score-display {
        word-spacing: -20px;
      }
      #score-display {
        font-size: 24px;
      }
      #restart-btn {
        line-height: 1.8;
      }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  </head>
  <body>
    <div id="game-container">
      <div class="scanlines"></div>
      <div id="ui-layer">
        <div id="score-display" class="hidden">SCORE: 0</div>

        <div id="start-screen" class="panel">
          <h1 id="game-title">Wybierz Gracza</h1>
          <div class="level-select">
            <button class="level-btn active" onclick="selectLevel(0)">
              Ojoj
            </button>
            <button class="level-btn" onclick="selectLevel(1)">Patec</button>
            <button class="level-btn" onclick="selectLevel(2)">Łatwo</button>
          </div>
          <p>Unikaj przeszkód.<br />Zbieraj swoje atrybuty.</p>
          <button id="start-btn">START</button>
        </div>

        <div id="game-over-screen" class="panel hidden">
          <h1 id="end-title">GAME OVER</h1>
          <div
            style="
              display: flex;
              justify-content: center;
              align-items: center;
              height: 100%;
              min-height: 48px;
            "
          >
            <p id="final-score-p" style="margin: 0">WYNIK:</p>
            <span
              id="final-score"
              style="color: var(--retro-green); margin-left: 8px"
              >0</span
            >
          </div>
          <button id="restart-btn">SPRÓBUJ PONOWNIE</button>
        </div>

        <div id="mobile-controls">
          <div id="btn-left" class="control-btn">❮</div>
          <div id="btn-right" class="control-btn">❯</div>
        </div>
      </div>
    </div>

    <script>
      const GAME_PARAMS = {
        physics: {
          laneWidth: 15,
          lanesCount: 5,
          baseSpeed: 0.5,
          maxSpeed: 2.0,
          acceleration: 0.0002,
          playerLerp: 0.2,
        },
        road: {
          length: 400,
          textureRepeats: 20,
        },
        graphics: {
          terrainSpeedFactor: -0.6,
        },
        gameplay: { duration: 30000 },
        spawning: { obstacleRate: 0.05, coinRate: 0.06, buildingRate: 0.08 },
      };

      const LEVELS = [
        {
          name: "Wojtek Piździecki",
          colors: {
            background: 0x87ceeb,
            fog: 0x87ceeb,
            road: "#F4A460",
            terrain: "#E3C896",
            roadStripes: "#F0E68C",
            uiPrimary: "#00ffff", // Retro Blue
            uiDanger: "#FF0000",
            uiSuccess: "#4af626",
          },
          assets: {
            player: { texture: "ojwojtek.png", width: 2.5, height: 4 },
            obstacle: {
              type: "png_sprite",
              texture: "szczecin.png",
              width: 2,
              height: 1,
            },
            coin: { model: "leaf.glb" },
            building: { model: "palm.glb" },
          },
          messages: {
            win: "Brawo! udało Ci się usmażyć swój mózg!",
            lose: "No i cyk do prokuratury!",
            buttonWin: "Essa, dawaj jeszcze raz!",
            buttonLose: "Dzwonię do Papugi",
          },
          gameplay: {
            coinValue: 20,
            winScore: 420,
            scoremessage: "Humor: ",
          },
          sounds: {
            coin: "sounds/coin.mp3",
            win: "sounds/azizam.mp3",
            lose: "sounds/loteria.mp3",
          },
        },
        {
          name: "Patec małpiarz",
          colors: {
            background: 0x2e8b57,
            fog: 0x4a7c59,
            road: "#5C4033",
            terrain: "#2E4F2F",
            roadStripes: "#8B4513",
            uiPrimary: "#4af626",
            uiDanger: "#DC143C",
            uiSuccess: "#ADFF2F",
          },
          assets: {
            player: { texture: "patec.png", width: 2.5, height: 4 },
            obstacle: {
              type: "png_sprite",
              texture: "mini_majk.png",
              width: 2,
              height: 3,
            },
            coin: { model: "banana.glb" },
            building: { type: "tree" },
          },
          messages: {
            win: "Klasa, małpy są z Ciebie dumne!",
            lose: "Mini Majk schował banany!",
            buttonWin: "Zagraj ponownie!",
            buttonLose: "Mini Majk to brzdąc",
          },
          gameplay: {
            coinValue: 10,
            winScore: 130,
            scoremessage: "Banany: ",
          },
          sounds: {
            coin: "sounds/coin.mp3",
            win: "sounds/azizam.mp3",
            lose: "sounds/majkel.mp3",
          },
        },
        {
          name: "Łatwo pijany",
          colors: {
            background: 0x87cefa,
            fog: 0xb0c4de,
            road: "#808080",
            terrain: "#444444",
            roadStripes: "#D3D3D3",
            uiPrimary: "#ff0099",
            uiDanger: "#B22222",
            uiSuccess: "#4169E1",
          },
          assets: {
            player: { texture: "latwo.png", width: 2.5, height: 4 },
            obstacle: {
              type: "png_sprite",
              texture: "shower.png",
              width: 2,
              height: 3,
            },
            coin: { model: "piwo.glb" },
            building: { type: "city_house" },
          },
          messages: {
            win: "No i klasa, zaliczyłeś zgona!",
            lose: "Weź prysznic Azizam",
            buttonWin: "Jeszcze mi mało!",
            buttonLose: "Już się umyłem",
          },
          gameplay: {
            coinValue: 0.3,
            winScore: 5.1,
            scoremessage: "Promile: ",
          },
          sounds: {
            coin: "sounds/coin.mp3",
            win: "sounds/azizam.mp3",
            lose: "sounds/latwo.mp3",
          },
        },
      ];

      const SoundFactory = {
        currentSounds: {
          coin: null,
          win: null,
          lose: null,
        },

        loadLevelSounds: function (levelConfig) {
          if (!levelConfig.sounds) {
            console.warn("No sounds defined for level: " + levelConfig.name);
            this.currentSounds = { coin: null, win: null, lose: null };
            return;
          }
          this.currentSounds.coin = new Audio(levelConfig.sounds.coin);
          this.currentSounds.win = new Audio(levelConfig.sounds.win);
          this.currentSounds.lose = new Audio(levelConfig.sounds.lose);
          this.currentSounds.coin.volume = 0.6;
        },

        play: function (type) {
          const audio = this.currentSounds[type];
          if (!audio) return;

          if (type === "coin") {
            const clone = audio.cloneNode();
            clone.volume = audio.volume;
            clone.play().catch((e) => console.warn("Audio play failed", e));
          } else {
            audio.currentTime = 0;
            audio.play().catch((e) => console.warn("Audio play failed", e));
          }
        },
      };

      const AssetFactory = {
        textureLoader: new THREE.TextureLoader(),
        gltfLoader: new THREE.GLTFLoader(),

        // Storage for our reusable objects
        pools: {
          obstacle: [],
          coin: [],
          building: [],
        },

        prototypes: {
          obstacle: null,
          coin: null,
          building: null,
        },
        textures: {},

        loadedModels: {},
        loadingStatus: {},
        waitingCallbacks: {},

        // --- POOLING SYSTEM ---

        resetPools: function () {
          Object.keys(this.pools).forEach((key) => {
            this.pools[key].forEach((obj) => {
              obj.visible = false;
              obj.position.set(0, -500, 0);
            });
          });
        },

        clearPools: function () {
          Object.keys(this.pools).forEach((key) => {
            this.pools[key].forEach((obj) => {
              if (scene) scene.remove(obj);

              obj.traverse((child) => {
                if (child.isMesh) {
                  if (child.geometry) child.geometry.dispose();
                  if (child.material) {
                    if (Array.isArray(child.material))
                      child.material.forEach((m) => m.dispose());
                    else child.material.dispose();
                  }
                }
              });
            });
            this.pools[key] = [];
          });
        },

        getFromPool: function (type, levelConfig, spawnLogic) {
          const pool = this.pools[type];
          let obj = pool.find((o) => !o.visible);

          if (obj) {
            obj.visible = true;
            return obj;
          }

          obj = spawnLogic.call(this, levelConfig);
          obj.userData.poolType = type;
          pool.push(obj);
          if (scene) scene.add(obj);

          return obj;
        },

        recycle: function (obj) {
          if (!obj) return;
          obj.visible = false;
          obj.position.set(0, -500, 0);
        },

        // --- INITIALIZATION ---

        initLevelAssets: function (levelConfig) {
          this.prototypes = { obstacle: null, coin: null, building: null };
          this.resetPools();

          const bData = levelConfig.assets.building;
          if (bData.model) {
            this.loadGLB(bData.model, (model) => {
              model.scale.set(1, 1, 1);
              this.prototypes.building = model;
            });
          } else if (bData.type === "palm") {
            this.prototypes.building = this.createPalmPrototype();
          } else if (bData.type === "tree") {
            this.prototypes.building = this.createJungleTreePrototype();
          } else {
            this.prototypes.building = this.createCityHousePrototype();
          }

          if (levelConfig.assets.obstacle.type === "png_sprite") {
            this.prototypes.obstacle =
              this.createSpriteObstaclePrototype(levelConfig);
          } else {
            this.prototypes.obstacle =
              this.createGeoObstaclePrototype(levelConfig);
          }

          const cData = levelConfig.assets.coin;
          if (cData.model) {
            this.loadGLB(cData.model, (model) => {
              const group = new THREE.Group();
              group.add(model.clone());
              this.prototypes.coin = group;
            });
          }
        },

        // --- SPAWNERS  ---

        getObstacle: function (levelConfig) {
          return this.getFromPool(
            "obstacle",
            levelConfig,
            this._createObstacleMesh
          );
        },
        getCoin: function (levelConfig) {
          return this.getFromPool("coin", levelConfig, this._createCoinMesh);
        },
        getBuilding: function (levelConfig) {
          return this.getFromPool(
            "building",
            levelConfig,
            this._createBuildingMesh
          );
        },

        _createObstacleMesh: function (levelConfig) {
          if (this.prototypes.obstacle) return this.prototypes.obstacle.clone();

          const mesh = new THREE.Mesh(
            new THREE.BoxGeometry(1, 1, 1),
            new THREE.MeshBasicMaterial({ color: 0xff0000 })
          );
          mesh.castShadow = true;
          mesh.userData.isObstacle = true;
          return mesh;
        },

        _createCoinMesh: function (levelConfig) {
          const cData = levelConfig.assets.coin;

          if (this.prototypes.coin) return this.prototypes.coin.clone();

          const group = new THREE.Group();
          let geo;
          if (cData.type === "torus")
            geo = new THREE.TorusGeometry(0.3, 0.1, 8, 16);
          else geo = new THREE.OctahedronGeometry(0.5, 0);

          const mat = new THREE.MeshStandardMaterial({
            color: cData.color || 0xffd700,
            emissive: cData.color || 0xffd700,
            emissiveIntensity: 0.6,
          });
          const fallback = new THREE.Mesh(geo, mat);
          group.add(fallback);
          return group;
        },

        _createBuildingMesh: function (levelConfig) {
          if (this.prototypes.building) {
            const b = this.prototypes.building.clone();

            if (levelConfig.assets.building.type === "city_house") {
              b.scale.y = 0.8 + Math.random() * 0.5;
            }
            if (levelConfig.assets.building.model === "palm.glb") {
              b.position.y += 10;
            }
            return b;
          }
          return new THREE.Mesh(
            new THREE.BoxGeometry(2, 10, 2),
            new THREE.MeshBasicMaterial({ color: 0x555555, wireframe: true })
          );
        },

        // --- ASSET HELPERS  ---

        loadGLB: function (path, onSuccess) {
          if (this.loadedModels[path]) {
            if (onSuccess) onSuccess(this.loadedModels[path]);
            return;
          }
          if (this.loadingStatus[path] === "loading") {
            if (onSuccess) {
              if (!this.waitingCallbacks[path])
                this.waitingCallbacks[path] = [];
              this.waitingCallbacks[path].push(onSuccess);
            }
            return;
          }
          this.loadingStatus[path] = "loading";
          if (onSuccess) this.waitingCallbacks[path] = [onSuccess];

          this.gltfLoader.load(
            path,
            (gltf) => {
              const rawModel = gltf.scene;
              rawModel.traverse((child) => {
                if (child.isMesh) {
                  child.castShadow = true;
                  child.receiveShadow = true;
                  if (child.material) {
                    child.material.side = THREE.DoubleSide;
                    if (child.material.transparent)
                      child.material.alphaTest = 0.5;
                  }
                }
              });

              const box = new THREE.Box3().setFromObject(rawModel);
              const size = box.getSize(new THREE.Vector3());
              const center = box.getCenter(new THREE.Vector3());
              const wrapper = new THREE.Group();
              wrapper.add(rawModel);
              const bottomY = box.min.y;
              rawModel.position.set(-center.x, -bottomY, -center.z);

              const maxDim = Math.max(size.x, size.y, size.z);
              if (maxDim > 0) {
                const targetSize = 1.5;
                const scaleFactor = targetSize / maxDim;
                wrapper.scale.set(scaleFactor, scaleFactor, scaleFactor);
              }

              this.loadedModels[path] = wrapper;
              this.loadingStatus[path] = "loaded";
              if (this.waitingCallbacks[path]) {
                this.waitingCallbacks[path].forEach((cb) => cb(wrapper));
                delete this.waitingCallbacks[path];
              }
            },
            undefined,
            (err) => {
              console.warn(`GLB Error (${path}):`, err);
              this.loadingStatus[path] = "error";
            }
          );
        },

        createDummyTexture: function (label, colorStr, type) {
          const key = label + colorStr + type;
          if (this.textures[key]) return this.textures[key];

          const cvs = document.createElement("canvas");
          cvs.width = 128;
          cvs.height = 128;
          const ctx = cvs.getContext("2d");

          if (type === "sprite") {
            ctx.clearRect(0, 0, 128, 128);
          } else {
            ctx.fillStyle = colorStr || "#999";
            ctx.fillRect(0, 0, 128, 128);
          }

          if (label.includes("placeholder")) {
            ctx.fillStyle = "white";
            ctx.font = "20px Arial";
            ctx.fillText("?", 50, 60);
          }

          const tex = new THREE.CanvasTexture(cvs);
          tex.magFilter = THREE.NearestFilter;
          this.textures[key] = tex;
          return tex;
        },

        createPlayer: function (levelConfig) {
          const pGroup = new THREE.Group();
          const pData = levelConfig.assets.player;
          const geometry = new THREE.PlaneGeometry(pData.width, pData.height);
          const fallbackMap = this.createDummyTexture(
            levelConfig.name,
            levelConfig.colors.uiPrimary,
            "default"
          );

          const texture = this.textureLoader.load(
            pData.texture,
            undefined,
            undefined,
            () => {
              mesh.material.map = fallbackMap;
            }
          );
          texture.magFilter = THREE.NearestFilter;

          const material = new THREE.MeshStandardMaterial({
            map: texture,
            transparent: true,
            alphaTest: 0.3,
            side: THREE.DoubleSide,
            roughness: 0.4,
          });

          const mesh = new THREE.Mesh(geometry, material);
          mesh.position.y = pData.height / 2;
          mesh.castShadow = true;
          pGroup.add(mesh);
          return pGroup;
        },

        createTerrainTexture: function (levelConfig) {
          const key = "terrain_" + levelConfig.name;
          if (this.textures[key]) return this.textures[key];
          const canvas = document.createElement("canvas");
          canvas.width = 512;
          canvas.height = 512;
          const ctx = canvas.getContext("2d");
          ctx.fillStyle = levelConfig.colors.terrain;
          ctx.fillRect(0, 0, 512, 512);
          ctx.fillStyle = "rgba(0,0,0,0.1)";
          for (let i = 0; i < 400; i++) {
            const x = Math.random() * 512;
            const y = Math.random() * 512;
            const s = 2 + Math.random() * 5;
            ctx.fillRect(x, y, s, s);
          }
          const texture = new THREE.CanvasTexture(canvas);
          texture.wrapS = THREE.RepeatWrapping;
          texture.wrapT = THREE.RepeatWrapping;
          texture.repeat.set(20, 20);
          texture.magFilter = THREE.NearestFilter;
          this.textures[key] = texture;
          return texture;
        },

        createRoadTexture: function (levelConfig) {
          const key = "road_" + levelConfig.name;
          if (this.textures[key]) return this.textures[key];
          const canvas = document.createElement("canvas");
          canvas.width = 512;
          canvas.height = 512;
          const ctx = canvas.getContext("2d");
          const c = levelConfig.colors;
          ctx.fillStyle = c.road;
          ctx.fillRect(0, 0, 512, 512);
          ctx.fillStyle = c.roadStripes;
          ctx.globalAlpha = 0.5;
          const lanePx = 512 / GAME_PARAMS.physics.lanesCount;
          for (let i = 1; i < GAME_PARAMS.physics.lanesCount; i++)
            ctx.fillRect(i * lanePx - 2, 0, 4, 512);
          ctx.globalAlpha = 1.0;
          ctx.fillRect(0, 0, 10, 512);
          ctx.fillRect(502, 0, 10, 512);
          const texture = new THREE.CanvasTexture(canvas);
          texture.wrapS = THREE.RepeatWrapping;
          texture.wrapT = THREE.RepeatWrapping;
          texture.repeat.set(1, GAME_PARAMS.road.textureRepeats);
          texture.magFilter = THREE.NearestFilter;
          this.textures[key] = texture;
          return texture;
        },

        // --- PALM TREE ---
        createPalmPrototype: function () {
          const group = new THREE.Group();
          const trunkMat = new THREE.MeshStandardMaterial({
            color: 0x8b4513,
            roughness: 1.0,
          });

          // Segmented Trunk
          const positions = [1.5, 4.2, 7.0];
          const radii = [0.8, 0.6, 0.5];

          positions.forEach((y, i) => {
            const geo = new THREE.CylinderGeometry(
              radii[i] * 0.8,
              radii[i],
              3,
              7
            );
            const mesh = new THREE.Mesh(geo, trunkMat);
            mesh.position.y = y;
            if (i > 0) {
              mesh.rotation.x = 0.1 * i;
              mesh.position.z = 0.2 * i;
            }
            group.add(mesh);
          });

          // Leaves Texture
          const leafGeo = new THREE.PlaneGeometry(2, 5);
          leafGeo.translate(0, 2.5, 0); // Pivot at bottom

          const ctx = document.createElement("canvas").getContext("2d");
          ctx.canvas.width = 64;
          ctx.canvas.height = 128;
          ctx.fillStyle = "#fff";
          ctx.beginPath();
          ctx.ellipse(32, 64, 30, 60, 0, 0, Math.PI * 2);
          ctx.fill();
          const leafTex = new THREE.CanvasTexture(ctx.canvas);

          const leafMat = new THREE.MeshStandardMaterial({
            color: 0x228b22,
            map: leafTex,
            alphaMap: leafTex,
            side: THREE.DoubleSide,
            transparent: true,
            alphaTest: 0.5,
          });

          // Layers, Interleaved angles
          const layers = 3;
          const leavesPerLayer = 6;

          for (let L = 0; L < layers; L++) {
            // Offset angle for every other layer to fill gaps
            const angleOffset = (Math.PI / leavesPerLayer) * (L % 2);
            const height = 8.2 - L * 0.5;
            const tilt = Math.PI / 3 - L * 0.1; // Top leaves point up more, bottom down more

            for (let i = 0; i < leavesPerLayer; i++) {
              const leaf = new THREE.Mesh(leafGeo, leafMat);
              const angle = (i / leavesPerLayer) * Math.PI * 2 + angleOffset;

              leaf.position.set(0, height, 0.9);
              leaf.rotation.y = angle;
              leaf.rotation.x = tilt;

              group.add(leaf);
            }
          }

          group.traverse((o) => {
            if (o.isMesh) o.castShadow = true;
          });
          group.scale.set(1.5, 1.5, 1.5);
          return group;
        },

        createJungleTreePrototype: function () {
          const group = new THREE.Group();

          // Thick, textured trunk with natural variation
          const trunkMaterial = new THREE.MeshStandardMaterial({
            color: 0x4a3520,
            roughness: 0.95,
            metalness: 0.05,
          });

          // Main trunk - wider at base
          const trunk = new THREE.Mesh(
            new THREE.CylinderGeometry(0.8, 1.6, 12, 8),
            trunkMaterial
          );
          trunk.position.y = 6;
          trunk.castShadow = true;
          group.add(trunk);

          // Add bark texture with protruding elements
          for (let i = 0; i < 5; i++) {
            const barkDetail = new THREE.Mesh(
              new THREE.BoxGeometry(0.3, 2, 0.3),
              new THREE.MeshStandardMaterial({ color: 0x3d2b1f })
            );
            const angle = (i / 5) * Math.PI * 2;
            barkDetail.position.set(
              Math.cos(angle) * 1.2,
              2 + i * 2,
              Math.sin(angle) * 1.2
            );
            barkDetail.rotation.y = angle;
            group.add(barkDetail);
          }

          // Exposed roots at base
          const rootMaterial = new THREE.MeshStandardMaterial({
            color: 0x3d2b1f,
            roughness: 0.9,
          });

          for (let i = 0; i < 6; i++) {
            const angle = (i / 6) * Math.PI * 2;
            const root = new THREE.Mesh(
              new THREE.CylinderGeometry(0.25, 0.4, 2, 6),
              rootMaterial
            );
            root.position.set(
              Math.cos(angle) * 1.2,
              0.5,
              Math.sin(angle) * 1.2
            );
            root.rotation.z = Math.cos(angle) * 0.5;
            root.rotation.x = Math.sin(angle) * 0.5;
            root.castShadow = true;
            group.add(root);
          }

          // Layered canopy - multiple levels for dense jungle look
          const darkGreen = new THREE.MeshStandardMaterial({
            color: 0x1a4d1a,
            roughness: 0.9,
          });

          const mediumGreen = new THREE.MeshStandardMaterial({
            color: 0x2d5a2d,
            roughness: 0.85,
          });

          const brightGreen = new THREE.MeshStandardMaterial({
            color: 0x3d7a3d,
            roughness: 0.8,
          });

          // Bottom canopy layer - largest and darkest
          const canopy1 = new THREE.Mesh(
            new THREE.SphereGeometry(4.5, 8, 8),
            darkGreen
          );
          canopy1.position.y = 11;
          canopy1.scale.set(1, 0.8, 1);
          canopy1.castShadow = true;
          group.add(canopy1);

          // Middle canopy layers - irregular shapes
          const canopy2 = new THREE.Mesh(
            new THREE.SphereGeometry(3.5, 8, 8),
            mediumGreen
          );
          canopy2.position.set(-1.5, 12.5, 1);
          canopy2.scale.set(1.2, 0.9, 1);
          canopy2.castShadow = true;
          group.add(canopy2);

          const canopy3 = new THREE.Mesh(
            new THREE.SphereGeometry(3.2, 8, 8),
            mediumGreen
          );
          canopy3.position.set(1.8, 12.8, -0.5);
          canopy3.scale.set(1, 1.1, 1.2);
          canopy3.castShadow = true;
          group.add(canopy3);

          // Top canopy - brightest, catches most light
          const canopy4 = new THREE.Mesh(
            new THREE.SphereGeometry(3, 8, 8),
            brightGreen
          );
          canopy4.position.set(0.5, 14, 0.2);
          canopy4.scale.set(1, 1.2, 1);
          canopy4.castShadow = true;
          group.add(canopy4);

          // Additional foliage clusters for density
          const foliageMaterial = new THREE.MeshStandardMaterial({
            color: 0x2d5a2d,
            roughness: 0.85,
          });

          for (let i = 0; i < 5; i++) {
            const angle = (i / 5) * Math.PI * 2;
            const cluster = new THREE.Mesh(
              new THREE.SphereGeometry(1.5 + Math.random() * 0.5, 6, 6),
              foliageMaterial
            );
            cluster.position.set(
              Math.cos(angle) * (3 + Math.random()),
              10.5 + Math.random() * 2,
              Math.sin(angle) * (3 + Math.random())
            );
            cluster.castShadow = true;
            group.add(cluster);
          }

          // Large branches emerging from canopy
          const branchMaterial = new THREE.MeshStandardMaterial({
            color: 0x3d2b1f,
            roughness: 0.9,
          });

          for (let i = 0; i < 4; i++) {
            const angle = (i / 4) * Math.PI * 2 + Math.PI / 8;
            const branch = new THREE.Mesh(
              new THREE.CylinderGeometry(0.3, 0.5, 4, 6),
              branchMaterial
            );
            branch.position.set(
              Math.cos(angle) * 1.5,
              10,
              Math.sin(angle) * 1.5
            );
            branch.rotation.z = Math.cos(angle) * 0.8;
            branch.rotation.x = Math.sin(angle) * 0.8;
            branch.castShadow = true;
            group.add(branch);

            // Smaller foliage at branch ends
            const branchFoliage = new THREE.Mesh(
              new THREE.SphereGeometry(1.8, 6, 6),
              brightGreen
            );
            branchFoliage.position.set(
              Math.cos(angle) * 4,
              11.5,
              Math.sin(angle) * 4
            );
            branchFoliage.scale.set(1, 0.8, 1);
            branchFoliage.castShadow = true;
            group.add(branchFoliage);
          }

          // Vines hanging down
          const vineMaterial = new THREE.MeshStandardMaterial({
            color: 0x3a5a2a,
            roughness: 0.8,
          });

          for (let i = 0; i < 3; i++) {
            const angle = Math.random() * Math.PI * 2;
            const vineLength = 4 + Math.random() * 3;
            const vine = new THREE.Mesh(
              new THREE.CylinderGeometry(0.08, 0.12, vineLength, 4),
              vineMaterial
            );
            vine.position.set(
              Math.cos(angle) * (2 + Math.random() * 2),
              11 - vineLength / 2,
              Math.sin(angle) * (2 + Math.random() * 2)
            );
            vine.rotation.z = (Math.random() - 0.5) * 0.3;
            vine.rotation.x = (Math.random() - 0.5) * 0.3;
            group.add(vine);
          }

          return group;
        },

        createCityHousePrototype: function () {
          const group = new THREE.Group();

          // Random color palettes for European tenements
          const colorPalettes = [
            { main: 0xd4b896, accent: 0xc9a875, roof: 0x8b4513 }, // Warm beige/ochre
            { main: 0xe8d5b7, accent: 0xd4c4a8, roof: 0x654321 }, // Light cream
            { main: 0xc9b8a3, accent: 0xb5a68f, roof: 0x5c4033 }, // Tan
            { main: 0xdcc9b3, accent: 0xc8b59f, roof: 0x704214 }, // Sand
            { main: 0xb8a890, accent: 0xa89478, roof: 0x6b4423 }, // Darker beige
            { main: 0xf5e6d3, accent: 0xe1d2bf, roof: 0x8b6914 }, // Pale yellow
          ];

          const palette =
            colorPalettes[Math.floor(Math.random() * colorPalettes.length)];

          // Main building body
          const buildingMaterial = new THREE.MeshStandardMaterial({
            color: palette.main,
            roughness: 0.9,
          });

          const mainBuilding = new THREE.Mesh(
            new THREE.BoxGeometry(6, 15, 6),
            buildingMaterial
          );
          mainBuilding.position.y = 7.5;
          mainBuilding.castShadow = true;
          group.add(mainBuilding);

          // Decorative horizontal bands (cornices)
          const bandMaterial = new THREE.MeshStandardMaterial({
            color: palette.accent,
            roughness: 0.8,
          });

          // Top cornice
          const topCornice = new THREE.Mesh(
            new THREE.BoxGeometry(6.3, 0.5, 6.3),
            bandMaterial
          );
          topCornice.position.y = 15;
          topCornice.castShadow = true;
          group.add(topCornice);

          // Mid-level decorative bands
          const midBand1 = new THREE.Mesh(
            new THREE.BoxGeometry(6.2, 0.3, 6.2),
            bandMaterial
          );
          midBand1.position.y = 10;
          group.add(midBand1);

          const midBand2 = new THREE.Mesh(
            new THREE.BoxGeometry(6.2, 0.3, 6.2),
            bandMaterial
          );
          midBand2.position.y = 5;
          group.add(midBand2);

          // Ground floor entrance door
          const doorMaterial = new THREE.MeshStandardMaterial({
            color: 0x4a3428,
            roughness: 0.7,
          });

          const door = new THREE.Mesh(
            new THREE.BoxGeometry(1.8, 3.5, 0.3),
            doorMaterial
          );
          door.position.set(0, 1.75, 3.05);
          group.add(door);

          // Small balconies
          const balconyMaterial = new THREE.MeshStandardMaterial({
            color: 0x8a8a8a,
            metalness: 0.5,
            roughness: 0.5,
          });

          for (let floor = 1; floor < 3; floor++) {
            const balcony = new THREE.Mesh(
              new THREE.BoxGeometry(2.8, 0.2, 0.9),
              balconyMaterial
            );
            balcony.position.set(0, 3.5 + floor * 3.5, 3.5);
            group.add(balcony);

            // Balcony railing
            const railing = new THREE.Mesh(
              new THREE.BoxGeometry(2.8, 0.9, 0.1),
              balconyMaterial
            );
            railing.position.set(0, 4 + floor * 3.5, 3.95);
            group.add(railing);
          }

          // Triangular roof
          const roofMaterial = new THREE.MeshStandardMaterial({
            color: palette.roof,
            roughness: 0.9,
          });

          // Create triangular roof using a pyramid/cone shape
          const roofHeight = 4;
          const roofGeometry = new THREE.ConeGeometry(5, roofHeight, 4);
          const roof = new THREE.Mesh(roofGeometry, roofMaterial);
          roof.position.y = 15.25 + roofHeight / 2;
          roof.rotation.y = Math.PI / 4; // Rotate 45 degrees to align with building
          roof.castShadow = true;
          group.add(roof);

          // Optional: Add a chimney randomly
          if (Math.random() > 0.3) {
            const chimneyMaterial = new THREE.MeshStandardMaterial({
              color: 0x8b4513,
              roughness: 0.8,
            });

            const chimney = new THREE.Mesh(
              new THREE.BoxGeometry(0.6, 2, 0.6),
              chimneyMaterial
            );
            const xOffset = (Math.random() - 0.5) * 3;
            const zOffset = (Math.random() - 0.5) * 3;
            chimney.position.set(xOffset, 16.5, zOffset);
            chimney.castShadow = true;
            group.add(chimney);

            // Chimney cap
            const cap = new THREE.Mesh(
              new THREE.BoxGeometry(0.8, 0.2, 0.8),
              chimneyMaterial
            );
            cap.position.set(xOffset, 17.6, zOffset);
            group.add(cap);
          }

          return group;
        },

        createGeoObstaclePrototype: function (levelConfig) {
          const oData = levelConfig.assets.obstacle;
          let geo =
            oData.type === "cylinder"
              ? new THREE.CylinderGeometry(0.8, 0.8, 1.5, 12)
              : new THREE.BoxGeometry(1.5, 1.5, 1.5);
          const mat = new THREE.MeshStandardMaterial({
            color: oData.color,
            emissive: oData.emissive || 0x000000,
          });
          const mesh = new THREE.Mesh(geo, mat);
          mesh.castShadow = true;
          return mesh;
        },
        createSpriteObstaclePrototype: function (levelConfig) {
          const data = levelConfig.assets.obstacle;
          const geo = new THREE.PlaneGeometry(data.width, data.height);
          let tex;
          if (data.texture.includes("_placeholder")) {
            tex = this.createDummyTexture(data.texture, null, "sprite");
          } else {
            tex = this.textureLoader.load(data.texture);
            tex.magFilter = THREE.NearestFilter;
          }
          const mat = new THREE.MeshStandardMaterial({
            map: tex,
            transparent: true,
            alphaTest: 0.5,
            side: THREE.DoubleSide,
          });
          const mesh = new THREE.Mesh(geo, mat);
          mesh.castShadow = true;
          mesh.userData.isObstacle = true;
          return mesh;
        },
      };

      // --- ENGINE VARIABLES ---
      let scene, camera, renderer;
      let currentLevelIndex = 0;
      let activeLevel = LEVELS[0];
      let player, roadMesh, terrainMesh;
      let obstacles = [],
        buildings = [],
        coins = [];
      let isRunning = false;
      let score = 0;
      let speed = 0;
      let gameStartTime = 0;

      let currentLane = 0;
      let targetX = 0;

      const ui = {
        score: document.getElementById("score-display"),
        start: document.getElementById("start-screen"),
        over: document.getElementById("game-over-screen"),
        finalScore: document.getElementById("final-score"),
        title: document.getElementById("game-title"),
        endTitle: document.getElementById("end-title"),
        endButton: document.getElementById("restart-btn"),
        btns: document.querySelectorAll(".level-btn"),
        finalScoreP: document.getElementById("final-score-p"),
      };

      function getLaneX(laneIndex) {
        return (
          laneIndex *
          (GAME_PARAMS.physics.laneWidth / GAME_PARAMS.physics.lanesCount)
        );
      }

      // ---  HELPER TO CLEAN MEMORY ---
      function dispose3DObject(obj) {
        if (!obj) return;
        scene.remove(obj);
        obj.traverse((child) => {
          if (child.isMesh) {
            if (child.geometry) child.geometry.dispose();
            if (child.material) {
              const mats = Array.isArray(child.material)
                ? child.material
                : [child.material];
              mats.forEach((m) => {
                if (m.map) m.map.dispose();
                m.dispose();
              });
            }
          }
        });
      }

      function initEngine() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(
          60,
          window.innerWidth / window.innerHeight,
          0.1,
          200
        );
        camera.position.set(0, 6, 9);
        camera.lookAt(0, 0, -10);

        renderer = new THREE.WebGLRenderer({
          antialias: false,
          powerPreference: "high-performance",
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document
          .getElementById("game-container")
          .appendChild(renderer.domElement);

        const ambLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(20, 50, 20);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        dirLight.shadow.camera.left = -20;
        dirLight.shadow.camera.right = 20;
        dirLight.shadow.camera.top = 20;
        dirLight.shadow.camera.bottom = -50;
        dirLight.shadow.camera.far = 100;
        scene.add(dirLight);

        setupInputs();
        window.addEventListener("resize", () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        });

        loadLevelVisuals(0);
        animate();
      }

      function loadLevelVisuals(index) {
        currentLevelIndex = index;
        activeLevel = LEVELS[index];

        SoundFactory.loadLevelSounds(activeLevel);

        ui.btns.forEach((btn, i) =>
          btn.classList.toggle("active", i === index)
        );
        ui.title.innerText = activeLevel.name;
        ui.title.style.color = activeLevel.colors.uiPrimary;

        AssetFactory.clearPools();

        dispose3DObject(player);
        dispose3DObject(roadMesh);
        dispose3DObject(terrainMesh);
        obstacles = [];
        coins = [];
        buildings = [];

        AssetFactory.initLevelAssets(activeLevel);

        scene.background = new THREE.Color(activeLevel.colors.background);
        scene.fog = new THREE.Fog(activeLevel.colors.fog, 20, 90);

        // --- ROAD ---
        const rGeo = new THREE.PlaneGeometry(
          GAME_PARAMS.physics.laneWidth,
          GAME_PARAMS.road.length
        );
        const rMat = new THREE.MeshStandardMaterial({
          map: AssetFactory.createRoadTexture(activeLevel),
          roughness: 0.8,
        });
        roadMesh = new THREE.Mesh(rGeo, rMat);
        roadMesh.rotation.x = -Math.PI / 2;
        roadMesh.position.z = -100;
        roadMesh.receiveShadow = true;
        scene.add(roadMesh);

        // --- TERRAIN ---
        const tGeo = new THREE.PlaneGeometry(300, 300);
        const tMat = new THREE.MeshStandardMaterial({
          map: AssetFactory.createTerrainTexture(activeLevel),
          roughness: 1.0,
        });
        terrainMesh = new THREE.Mesh(tGeo, tMat);
        terrainMesh.rotation.x = -Math.PI / 2;
        terrainMesh.position.y = -0.1;
        terrainMesh.position.z = -100;
        terrainMesh.receiveShadow = true;
        scene.add(terrainMesh);

        player = AssetFactory.createPlayer(activeLevel);
        scene.add(player);
      }

      window.selectLevel = function (index) {
        if (isRunning) return;
        loadLevelVisuals(index);
      };

      function startGame() {
        if (isRunning) return;
        score = 0;
        speed = GAME_PARAMS.physics.baseSpeed;
        currentLane = 0;
        targetX = getLaneX(0);
        player.position.x = targetX;
        player.rotation.set(0, 0, 0);

        AssetFactory.resetPools();
        obstacles = [];
        coins = [];
        buildings = [];

        ui.start.classList.add("hidden");
        ui.over.classList.add("hidden");
        ui.score.classList.remove("hidden");
        if (activeLevel.gameplay.coinValue === 0.3) {
          ui.score.style.fontSize = "20px";
        }
        ui.score.innerText = `${activeLevel.gameplay.scoremessage} 0 / ${activeLevel.gameplay.winScore}`;
        gameStartTime = Date.now();

        isRunning = true;
      }

      function stopGame(reason) {
        isRunning = false;
        ui.score.classList.add("hidden");
        ui.over.classList.remove("hidden");
        ui.finalScore.innerText = score;
        ui.finalScoreP.innerText = activeLevel.gameplay.scoremessage;
        if (reason === "finish") {
          SoundFactory.play("win");
          ui.endTitle.innerText = activeLevel.messages.win;
          ui.endButton.innerText = activeLevel.messages.buttonWin;
          ui.endTitle.style.color = activeLevel.colors.uiSuccess;
          ui.finalScore.style.color = activeLevel.colors.uiSuccess;
        } else {
          SoundFactory.play("lose");
          ui.endTitle.innerText = activeLevel.messages.lose;
          ui.endButton.innerText = activeLevel.messages.buttonLose;
          ui.endTitle.style.color = "#ff3333";
          ui.finalScore.style.color = "#fff";
        }
      }

      function returnToMenu() {
        ui.over.classList.add("hidden");
        ui.start.classList.remove("hidden");
        loadLevelVisuals(currentLevelIndex);
      }
      function changeLane(dir) {
        const maxLane = Math.floor(GAME_PARAMS.physics.lanesCount / 2);
        const next = currentLane + dir;
        if (next >= -maxLane && next <= maxLane) {
          currentLane = next;
          targetX = getLaneX(currentLane);
        }
      }

      function update() {
        if (!isRunning) return;

        // 1. Physics & Environment
        speed += GAME_PARAMS.physics.acceleration;
        if (speed > GAME_PARAMS.physics.maxSpeed)
          speed = GAME_PARAMS.physics.maxSpeed;

        if (roadMesh.material.map)
          roadMesh.material.map.offset.y -=
            speed / (GAME_PARAMS.road.length / GAME_PARAMS.road.textureRepeats);

        if (terrainMesh && terrainMesh.material.map) {
          const terrainSpeed = speed * GAME_PARAMS.graphics.terrainSpeedFactor;
          terrainMesh.material.map.offset.y -= (terrainSpeed / 300) * 20;
        }

        const maxLane = Math.floor(GAME_PARAMS.physics.lanesCount / 2);

        if (Math.random() < GAME_PARAMS.spawning.obstacleRate) {
          const obs = AssetFactory.getObstacle(activeLevel);
          const laneIdx =
            Math.floor(Math.random() * GAME_PARAMS.physics.lanesCount) -
            maxLane;

          // Reset Position
          obs.position.set(
            getLaneX(laneIdx),
            obs.userData.isObstacle ? 1.5 : 0.75,
            -80
          );

          if (!obstacles.includes(obs)) obstacles.push(obs);
        }

        if (Math.random() < GAME_PARAMS.spawning.coinRate) {
          const c = AssetFactory.getCoin(activeLevel);
          const laneIdx =
            Math.floor(Math.random() * GAME_PARAMS.physics.lanesCount) -
            maxLane;
          c.position.set(getLaneX(laneIdx), 1.0, -80);
          c.rotation.set(0, 0, 0); // Reset rotation
          if (!coins.includes(c)) coins.push(c);
        }

        if (Math.random() < GAME_PARAMS.spawning.buildingRate) {
          const b = AssetFactory.getBuilding(activeLevel);
          const side = Math.random() > 0.5 ? 1 : -1;
          const dist =
            GAME_PARAMS.physics.laneWidth / 2 + 5 + Math.random() * 5;
          b.position.set(side * dist, 0, -90);
          b.rotation.y = Math.random() * Math.PI * 2;
          if (!buildings.includes(b)) buildings.push(b);
        }

        const moveObj = (arr, type) => {
          for (let i = arr.length - 1; i >= 0; i--) {
            const obj = arr[i];

            if (!obj.visible) {
              arr.splice(i, 1);
              continue;
            }

            obj.position.z += speed;
            if (type === "coin") obj.rotation.y += 0.05;

            if (obj.position.z > -1.5 && obj.position.z < 1.5) {
              const dist = Math.abs(obj.position.x - player.position.x);

              if (type === "obstacle" && dist < 1.2) {
                stopGame("crash");
              } else if (type === "coin" && dist < 1.2) {
                AssetFactory.recycle(obj);
                arr.splice(i, 1);

                SoundFactory.play("coin");
                score += activeLevel.gameplay.coinValue;
                score = Math.round(score * 10) / 10;

                ui.score.innerText = `${activeLevel.gameplay.scoremessage} ${score} / ${activeLevel.gameplay.winScore}`;
                if (score >= activeLevel.gameplay.winScore) {
                  stopGame("finish");
                  return;
                }
                continue;
              }
            }

            if (obj.position.z > 20) {
              AssetFactory.recycle(obj);
              arr.splice(i, 1);
            }
          }
        };

        moveObj(obstacles, "obstacle");
        moveObj(coins, "coin");
        moveObj(buildings, "building");

        player.position.x +=
          (targetX - player.position.x) * GAME_PARAMS.physics.playerLerp;
        const tilt = (player.position.x - targetX) * 0.15;
        player.rotation.z = tilt;
        player.rotation.y = -tilt * 0.5;
      }

      function setupInputs() {
        document.addEventListener("keydown", (e) => {
          if (isRunning) {
            if (e.key === "ArrowLeft") changeLane(-1);
            if (e.key === "ArrowRight") changeLane(1);
          }
        });
        const handleTap = (dir) => (e) => {
          e.preventDefault();
          if (!isRunning) return;
          changeLane(dir);
          // Button feedback
          const btn = e.target.closest(".control-btn");
          if (btn) {
            btn.style.background = "var(--retro-blue)";
            btn.style.color = "#000";
            setTimeout(() => {
              btn.style.background = "rgba(255,255,255,0.1)";
              btn.style.color = "var(--retro-blue)";
            }, 100);
          }
        };
        const btnL = document.getElementById("btn-left");
        const btnR = document.getElementById("btn-right");
        btnL.addEventListener("touchstart", handleTap(-1), { passive: false });
        btnR.addEventListener("touchstart", handleTap(1), { passive: false });
        btnL.addEventListener("mousedown", handleTap(-1));
        btnR.addEventListener("mousedown", handleTap(1));
        document
          .getElementById("start-btn")
          .addEventListener("click", startGame);
        document
          .getElementById("restart-btn")
          .addEventListener("click", returnToMenu);
      }
      function animate() {
        requestAnimationFrame(animate);
        update();
        renderer.render(scene, camera);
      }
      initEngine();
    </script>
  </body>
</html>
